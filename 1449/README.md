# BOJ 1449 - 수리공 항승

## 문제 설명
- [문제 링크](https://www.acmicpc.net/problem/1449)
- 물이 새는 곳 N개와 테이프의 길이 L이 주어진다.
- 테이프를 이용해 물이 새는 곳을 막아야 한다.
- 테이프는 물이 새는 곳의 좌우 0.5만큼 간격을 줘야 물이 새지 않는다.
- 테이프는 자를 수 없고, 겹쳐서 붙이는 것이 가능하다.
- 필요한 테이프의 최소 개수를 구하는 문제이다.

## 아이디어
- **그리디 알고리즘**을 사용한다.
- 물이 새는 위치를 오름차순으로 정렬한다.
- 가장 왼쪽의 물이 새는 곳부터 테이프를 붙인다.
- 테이프 하나가 최대한 많은 구멍을 막도록 하는 것이 핵심이다.

## 풀이 과정
1. 물이 새는 곳의 개수 N과 테이프의 길이 L을 입력받는다.
2. 물이 새는 곳의 위치를 입력받아 오름차순으로 정렬한다.
3. 첫 번째 위치부터 테이프를 붙인다고 가정하고, 필요한 테이프 개수 `ans`를 1로 초기화한다.
4. 테이프가 커버할 수 있는 최대 범위를 `target`으로 설정한다. (첫 위치 + L - 1)
5. 정렬된 위치를 순회하면서 현재 위치가 `target`보다 작거나 같으면, 하나의 테이프로 막을 수 있으므로 넘어간다.
6. 만약 현재 위치가 `target`보다 크면, 새로운 테이프가 필요하므로 `ans`를 1 증가시키고 `target`을 현재 위치 기준으로 새로 설정한다.
7. 모든 위치를 순회할 때까지 반복하고 `ans`를 출력한다.

## 코드 설명
```python
import sys
input = sys.stdin.readline

N, L = map(int, input().split())

arr = list(map(int, input().split()))
arr.sort()
i, ans = 0, 0

while i < N:
    target = arr[i] + L - 1
    ans += 1
    while i < N and arr[i] <= target:
        i += 1

print(ans)
```
- `arr.sort()`: 물이 새는 위치를 오름차순으로 정렬하여 그리디 알고리즘을 적용할 준비를 한다.
- `while i < N`: 모든 위치를 확인할 때까지 반복한다.
- `target = arr[i] + L - 1`: 현재 위치 `arr[i]`에 테이프를 붙였을 때, 테이프가 막을 수 있는 최대 범위를 계산한다. (길이가 L이므로 `arr[i]`부터 `arr[i] + L - 1`까지 커버 가능)
- `ans += 1`: 새로운 테이프를 사용하므로 개수를 1 증가시킨다.
- `while i < N and arr[i] <= target`: 현재 테이프가 커버할 수 있는 범위 내에 있는 다음 위치들을 건너뛰기 위해 `i`를 증가시킨다.