# BOJ 9095 - 1, 2, 3 더하기

## 문제 설명
- [문제 링크](https://www.acmicpc.net/problem/9095)
- 정수 n을 1, 2, 3의 합으로 나타내는 방법의 수를 구하는 문제.
- 단, 순서가 다르면 다른 경우로 센다.

    - 예시)  
    n = 4 → (1+1+1+1), (1+1+2), (1+2+1), (2+1+1), (2+2), (1+3), (3+1) → 7가지

## 아이디어
- DP(동적 프로그래밍) 문제.
- 점화식: dp[n] = dp[n-1] + dp[n-2] + dp[n-3]
    - 마지막에 1을 더하는 경우 → dp[n-1]  
    - 마지막에 2를 더하는 경우 → dp[n-2]  
    - 마지막에 3을 더하는 경우 → dp[n-3]
- 초기값:  
    - dp[1] = 1 (1)  
    - dp[2] = 2 (1+1, 2)  
    - dp[3] = 4 (1+1+1, 1+2, 2+1, 3)

## 풀이 과정
1. dp 배열을 미리 계산해둔다 (n ≤ 10).  
2. 테스트케이스 T를 입력받음.  
3. 각 테스트케이스에 대해 dp[n] 출력.

## 코드 설명
```python
import sys
input = sys.stdin.readline

dp = [0] * 11
dp[1] = 1
dp[2] = 2
dp[3] = 4

for i in range(4, 11):
  dp[i] = dp[i-1] + dp[i-2] + dp[i-3]

T = int(input())
for i in range(T):
  n = int(input())
  print(dp[n])
```
- dp 배열에 1~10까지 방법의 수를 미리 계산.

- 점화식을 이용해 O(1)로 각 테스트케이스에 답할 수 있음.