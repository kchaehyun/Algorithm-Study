# BOJ 1463 - 1로 만들기

## 문제 설명
- [문제 링크](https://www.acmicpc.net/problem/1463)
- 정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지이다.
    1. X가 3으로 나누어 떨어지면, 3으로 나눈다.
    2. X가 2로 나누어 떨어지면, 2로 나눈다.
    3. 1을 뺀다.
- 정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력한다.

## 아이디어
- 다이나믹 프로그래밍(Dynamic Programming)을 이용하여 문제를 해결한다.
- `dp[i]`를 `i`를 1로 만드는 데 필요한 최소 연산 횟수로 정의한다.
- `i`에 대해 3가지 연산을 적용했을 때의 이전 값들(`dp[i-1]`, `dp[i//2]`, `dp[i//3]`)을 이용하여 `dp[i]`를 점화식으로 표현한다.

## 시간복잡도
- O(N)

## 풀이 과정
1. 크기가 N+1인 dp 테이블을 초기화한다.
2. 반복문을 통해 2부터 N까지 다음 점화식을 이용하여 dp 테이블을 채운다.
   - `dp[i] = dp[i-1] + 1` (1을 빼는 연산)
   - `i`가 2의 배수인 경우, `dp[i] = min(dp[i], dp[i//2] + 1)`
   - `i`가 3의 배수인 경우, `dp[i] = min(dp[i], dp[i//3] + 1)`
3. `dp[N]`을 출력한다.

## 코드 설명
```python
import sys
input = sys.stdin.readline

N = int(input())
dp = [0] * (N+1)

for i in range(2, N+1):
    dp[i] = 1+dp[i-1]
    if i%2 == 0:
        dp[i] = min(1+dp[i//2], dp[i])
    if i%3 == 0:
        dp[i] = min(1+dp[i//3], dp[i])

print(dp[N])
```
- `dp[i]`는 숫자 `i`를 1로 만드는 데 필요한 최소 연산 횟수를 저장한다.
- `i`를 1로 만드는 방법은 3가지가 있다.
    1. `i-1`에서 1을 더하는 연산: `dp[i-1] + 1`
    2. `i`가 2의 배수일 때, `i/2`에서 2를 곱하는 연산: `dp[i//2] + 1`
    3. `i`가 3의 배수일 때, `i/3`에서 3을 곱하는 연산: `dp[i//3] + 1`
- 위 3가지 방법 중 가장 작은 값을 `dp[i]`에 저장한다.
